# item12. 컴포넌트
컴포넌트는 배포 단위  

## 컴포넌트의 간략한 역사
초창기 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.

## 재배치성
- 해결책은 재배치가 가능한 바이너리
  - 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시
  - 여러 개의 바이너리를 입력받은 후, 하나씩 차례로 메모리로 로드하면서 재배치
  - 프로그램이 라이브러리 함수를 호출 = 외부 참조
  - 라이브러리 함수를 정의하는 프로그램 = 외부 정의

- 링킹로드: 프로그램을 로드하는 동시에 링크까지 수행하는 로더

## 링커
- 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할 가능

로드와 링크가 두 단계로 분리
- 프로그래머는 링크의 과정을 맡음.
  - 링커라는 별도의 애플리케이션으로 이 작업을 처리함.
  - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라짐.

프로그램 크기와 관련된 머피의 법칙
- 컴파일하고 링크하는 데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다.

## 결론
런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트

# item13. 컴포넌트 응집도
- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙

## REP: 재사용/릴리스 등가 원칙
재사용 단위는 릴리스 단위와 같다.  

- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면,   해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.

- 소프트웨어 설계와 아케틱처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻하다.

- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다.

## CCP: 공통 폐쇄 원칙
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.

- 이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것.
  - 단일 클래스는 변경의 이유가 여러 개 있어서는 안된다 == 공통 폐쇄 원칙에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다.

- 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
  - 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

변경될 가능성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다.
ㄴ 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.

OCP(개방 폐쇄 원칙) - 변경에는 닫혀있고, 확장에는 열려있다.

### SRP(단일 책임 원칙)와의 유사성
CCP는 컴포넌트 수준의 SRP이다.  

| SRP                               | CCP                                |
|-----------------------------------|------------------------------------|
| 서로 다른 이유로 변경되는 메스드를 서로 다른 클래스로 분리 | 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리 |

## CRP: 공통 재사용 원칙
컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다.
- 개별 클래스는 단독으로 재사용되는 경우가 거의 없다. => 재사용 가능한 ㅡㅋㄹ래스는 재사용 모듈의 일부로써, 해당 모듈의 다른 클래스와 상호작용

예)  
컨테이너 클래스와 이터레이터 클래스  
두 클래스는 강하게 결합되어 있기 때문에 함께 재사용 된다.  
두 클래스는 반드시 동일한 컴포넌트에 위치해야 한다.

A컴포넌트가 B컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다.  
이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때 마다, 사용하는 컴포넌트도 변경해야 할 가능성이 높다.  
- 따라서 의존하는 컴포넌트가 있다면, 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

### CRP는 어떤 클래스를 한데 묶어도 되는지보다는 어떤 클래스를 한데 묶어서는 안되는지에 대해 더 많은 중점을 둔다.

### ISP와의 관계
CRP는 ISP(인터페이스 분리 원칙)보다 더 포괄적인 버전이다.

| CRP                           | ISP                          |
|-------------------------------|------------------------------|
| 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 마라 | 사용하지 않은 메서드가 있는 클래스에 의존하지 마라 |

## 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 관한 세 원칙은 서로 상충  

- REP와 CCP는 포함 원칙
  - 두 원칙은 컴포넌트를 더욱 크게 만든다
- CRP는 배제 원칙
  - 컴포넌트를 더욱 작게 만든다.

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때, 너무 많은 컴포넌트에 영향을 미치며,  
CCP와 REP에만 과도하게 집중하면, 불필요한 릴리스가 너무 빈번해진다.

## 결론
과거에는 응집도를 '모듈은 단 하나의 기능만 수행해야 한다'는 속성 정도로 이해했음.  

컴포넌트 응집도에 관한 세 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명  
- 어느 클래스들을 묶어서 컴포넌트로 만들지, 재사용성과 개발가능성이라는 상충하는 힘을 반드시 고려해야 함
- 하지만 프로젝트의 초점이 바뀜에 따라(개발 가능성 -> 재사용성), 컴포넌트를 구성하는 방식도 진화

# item14. 컴포넌트 결합
컴포넌트 사이의 관계

## ADP: 의존성 비순환 원칙
컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생하는 문제.  
2가지 해결법
- 주 단위 빌드
- 의존성 비순환 원칙

### 주 단위 빌드
- 4일은 각자 코딩, 5일 째 되는 날 통합

### 순환 의존성 제거하기
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리
- 각 팀은 티멩 맞는 버전의 릴리스를 사용

이 방법은 성공하기 위해서는  
컴포넌트 사이의 읜존성 구조를 반드시 관리해야 하며, 의존성 구조에 순환이 있어서는 안됨.

- 비 순환 방향 그래프의 의존성을 가지며, 이를 통해 컴포넌트 간의 의존성을 관리
- 시스템 전체를 릴리스 해야하면, 상향식으로 진행

### 순환이 컴포넌트 의존성 그래프에 미치는 영향
순환이 생기게 되면, 연관된 모든 컴포넌트에 영향을 끼쳐, 모두 동일한 릴리스를 사용해야 함

### 순환 끊기
컴포넌트 사이의 순환을 끊고, 의존성을 다시 DAG로 원상복구 하기.
1. 의존성 역전 원칙(DIP)을 사용
2. 순환이 생긴 컴포넌트 모두가 의존하는 새로운 컴포넌트를 만든다.

### 흐트러짐
새로운 컴포넌트를 만드는 방법처럼, 요구사항에 의해 컴포넌트 구조는 변경될 수 있다.

### 하향식 설계
'컴포넌트 구조는 하향식으로 설계될 수 없다' 라는 결론에 도달하게 된다.  
컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 시스템과 같이 성장하고 변경된다.

컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
- 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며, 고가치를 지닌 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

### SDP: 안정된 의존성 원칙
안정성의 방향을 보고, 더 안정된 쪽에 의존하다.  
모듈을 만들 때 변경하기 쉽도록 설계했지만, 누군가가 의존성을 달아 버리면, 나의 모듈도 변경하기 어려워진다.

안정성 의존 원칙을 준수하면, 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

#### 안정성
- 쉽게 움직이지 않는

안정적인 컴포넌트란 변경하기 어려운 컴포넌트이며, 변경하기 어려우려면, 다른 많은 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.

#### 안정성 지표
- 위치 상 어느정도의 안정성을 가지는지 계산
  - Fan-in: 안으로 들어오는 의존성
  - Fan-out: 밖으로 나가는 의존성
  - I(불안정성): I = Fan-out / (Fan-in + Fan-out) [0,1]의 범위를 가지며, 0이면 최고로 안정

#### 모든 컴포넌트가 안정적이여야 하는 것은 아니다.
모든 컴포넌트가 안정적 = 변경 불가능 = 바람직한 상황 아님

다이어 그램을 그릴 때, 위쪽에는 불안정한 컴포넌트를 두고, 아래쪽에 안정한 컴포넌트를 둔다.
- 위로 향하는 화살표가 있다면, SDP(안정된 의존성 원칙) 위배

#### 추상 컴포넌트
인터페이스만 포함하는 컴포넌트를 생성하는 이유?  
정적 타입 언어에서는 매우 흔하다.  

추상 컴포넌트는 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이 된다.

### SAP: 안정된 추상화 원칙
컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?
자주 변경해서는 절대로 안되는 소프트웨어 = 고수준 아키텍처 / 정책 결정과 관련된 소프트웨어

하지만, 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기 어려워진다.

- 컴포넌트가 최고로 안정된 상태 이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들기???
- 개방 폐쇄 원칙(OCP)에서 찾을 수 있다.

OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만드는게 바람직한 방식이라고 한다  
즉, 추상 클래스가 해당 원칙을 준수한다.

### 안정된 추상화 원칙
안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
- 안정된 컴포넌트는 추상 컴포넌트여야 하며, 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다.
- 불안정한 컴포넌트는 반드시 구현 컴포넌트여야 한다 = 컴포넌트가 불안정하므로, 컴포넌트 내부의 구체적인 코드도 쉽게 변경 가능  
##### 즉, 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
의존성은 추상화의 방향으로 향하게 된다.

#### 추상화 정도 측정하기
Nc: 컴포넌트의 클래스 개수
Na: 추상 클래스와 인터페이스 개수
A(추상화 정도): A = Na / Nc

세로선은 A, 가로선은 I인 그래프
- 0,0은 고통의 구역이다.
  - 이 컴포넌트는 매우 안정적이며 구체적이다. - 변동성이 없다.
  - 보통 db 스키마가 해당 구역에 위치한다.
  - 구체적인 유틸리티 라이브러리도 위치한다.

- 1,1은 쓸모없는 구역이다.
  - 이 컴포넌트는 최고로 추상적이지만, 누구도 이 컴포넌트에 의존하지 않는다.
  - 이 구역에 위치한 컴포넌트는 아무것도 하지 않는다.
  - 보통 누구도 구현하지 않은 채 남겨진 추상 클래스인 경우가 많다.
  
##### 주계열
- D: |A + I - 1| [0,1]의 범위를 가진다.
- 너무 추상적이지도, 너무 불안정하지도 않음.
- 0이면 주계열에 가까이 위치, 1이면 멀리 있음
- 0에 가깝지 않다면, 재검토 후 재구성 가능
