# item4. 구조적 프로그래밍
데이크스트라는 증명이라는 수학적인 원리를 적용하여 프로그래밍의 문제를 해결하려 함

## 증명
- goto문장은 재귀적으로 분해하는 과정에 방해가 됨
  - goto문장은 분기와 반복이라는 단순한 제어구조에 해당
- 모듈을 분해할 수 없다면, 분할 정복 접근법 을 사용 못함
- 모듈이 제어 구조만을 사용한다면, 증명 가능한 단위로까지 모듈을 재귀적으로 세분화 가능
- 제어 구조는 순차 실행과 결합했을 때 특별하다
  - 모든 프로그램은 순차, 분기, 반복 이라는 세 가지 구조만으로 표현 가능

## 해로운 성명서
- 데이크스트라에 반대되는 의견이 있었지만, 결국 데이크스트라가 승리
- 우리 모두는 구조적 프로그래머이며, 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공 안함

## 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해 가능 -> 모듈을 기능적으로 분해 가능
- 거대한 문제 기술서 -> 고수준의 기능들로 분해 -> 저수준의 함수로 분해 -> 반복 -> 구조적 프로그래밍의 제한된 제어 구조로 표현 가능

## 엄밀한 증명은 없었다.
프로그램 관점에서 정리에 대한 유클리드 계층 구조는 없었지만, 과학적 방법이 존재.

## 과학이 구출하다.
과학적 방법은 반증은 가능하지만, 증명은 불가능하다.
수학은 증명 가능한 서술이 참임을 입증하는 원리지만, 과학은 증명 가능한 서술이 거짓임을 입증하는 원리

## 테스트
데이크스트라는 '테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다'

# 결론
구조적 프로그래밍이 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문.


# item5. 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일 => 객체 지향(Object-Oriented) 설계 원칙을 이해하고 응용
OO의 본질을 설명하기 위한 세 가지 주문
- 캡슐화
- 상속
- 다형성

## 캡슐화?
데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공
- 이 개념들은 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현
- 하지만 많은 언어가 캡슐화를 강제하진 않음.

## 상속?
- 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의 하는 일
- 상속은 업캐스팅이 암묵적으로 이루어 짐

## 다형성?
- 행위가 타입에 의존한다.
- 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해줌.

## 다형성이 가진 힘
- 다형성을 쓰면, 플러그인 형태로 만들어서, 범용적으로 사용 가능.
- 플러그인 아키텍처는 독립성을 지원하기 위해 만들어 짐

## 의존성 역전
다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전, 소프트 웨어 호출 트리
- main -> 고수준 함수 -> 중간 수준 함수 -> 저수준 함수 =>소스 코드 의존성의 방향은 제어흐름을 따르게 된다.

- 소스 코드 의존성은 인터페이스를 추가하여, 방향을 역전할 수 있음.
- 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않아, 소스 코드 의존성을 원하는 방향으로 설정 가능.
- UI와 데이터베이스가 업무 규칙의 플러그인이 된다. == 업무 규칙의 소스 코드에서는 UI나 데이터베이스를 호출하지 않음.
- 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 되니, 배포 독립성을 가질 수 있고, 모듈을 독립적으로 개발할 수 있으니, 개발 독립성을 가짐.

# 결론
OO란 다형성을 이용하여, 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력.  
OO를 사용하면, 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성 보장.  
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포 가능

# item6. 함수형 프로그래밍
패러다임에서 핵심이 되는 기반은 람다 계산법

## 정수를 제곱하기
자바 프로그램은 가변 변수를 사용한다.  
클로저 프로그램에서는 가변 변수가 전혀 없다. => 함수형 언어에서 변수는 변경되지 않는다.

## 불변성과 아키텍처
- 아키텍트는 왜 변수의 가변성을 염려하는가?
  - 경합조건
  - 교착상태 조건
  - 동시 업데이트
- 즉, 동시성 애플리케이션에서 마주치는 모든 문제인 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 생기지 않음.

## 가변성의 분리
- 애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일.
  - 불변 컴포넌트
    - 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않음.
    - 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
- 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여, 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호

- 애플리케이션을 제대로 구조화 하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 함.

## 이벤트 소싱
- 이벤트 소싱에 깔려있는 기본 발상
  - 애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 됨.
  - 상태가 아닌 트랜잭션을 저장하자는 전략 == 상태가 필요해지면, 단순히 상태의 시작점부터 모든 트랜잭션을 처리
- 결과적으로 애플리케이션은 CRUD가 아닌 CR만 수행하기 때문에, 동시 업데이트 문제 또한 일어나지 않음.
- 즉, 저장 공간과 처리 능력이 충분하면, 애플리케이션이 완전한 불변성을 갖도록 만들 수 있음.

# 결론
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다.
