# item6 의존관계
## 6.1 의존 관계의 예
의존관계는 코드를 작성하는 데 필수적인 요소이지만, 적절히 다루지 않으면 코드의 가독성과 견고함을 쉽게 해칠 수도 있다.
## 6.2 의존의 강도: 결합도
결합도: 클래스 간의 상호 의존 정도 또는 연관 관계의 끈끈함 정도를 나타내는 지표  
- 결합도가 높음
  - 내용 결합
  - 공통 결합
  - 외부 결합
  - 제어 결합
  - 스탬프 결합
  - 데이터 결합
  - 메시지 결합  
- 결합도가 낮음

### 6.2.1 내용 결합
- 사용되는 쪽 클래스 코드를 변경
- 사용되는 쪽 클래스에 은닉된 변수를 외부에서 참조
- 사용되는 쪽 클래스 안에 있는 코드로 직접 점프  
하는 코드의 세부 사항에 의존하면 발생하는 가장 높은 결합도를 가지는 결합

#### 안티패턴1: 잘못된 방법으로 사용되기 쉬운 코드
- 함수의 호출 순서가 정해져 있는 코드
- 수신 객체나 인수의 상태에 제약이 있는 코드
#### 개선방법1: 호출하는 쪽에 두는 제약을 최소화하기
- 값 전달에 인수와 반환값을 사용하여, 강제로 함수를 호출하고 결괏값을 전달한다.
- 호출할 순서가 정해져 있는 함수들을 의존 대상으로 묶어 은닉한다.

#### 안티패턴2: 내부 상태를 공유하는 코드
- 한 변수가 여러 객체, 그 중에서도 서로 다른 클래스의 인스턴스로부터 변경되는 경우, '어느 객체가 변경에 대한 책임을 가지는지'를 명확히 해야한다.
#### 개선방법2: 가변 상태에 대한 책임을 단일화하기

### 6.2.2. 공통 결합과 외부 결합
- 전역 변수를 사용하여 값을 전달할 때
- 가변 싱글턴 객체를 사용할 때
- I/O, 공유 메모리와 같이 코드에서 단일하게 취급하는 외부 리소스를 이용할 때
와 같이 누구나 읽기/쓰기가 가능한 곳에서 값을 주고 받을 때 발생

#### 안티패턴1: 전역 변수를 사용하여 값을 전달하기
- 전역 변수를 사용하면, '값 전달'과 '함수 호출' 사이에 연관성이 없어지기 때문에, 가독성과 견고함이 떨어진다.
#### 개선방법1: 인수와 반환값을 사용하여 값 전달하기

#### 안티패턴2: 가변 싱글턴 객체를 사용하기
- 가변 객체를 가진 싱글턴을 사용하게 되면, 싱글턴으로 코드의 모든 곳에 상태를 공유하게 된다.
#### 개선방법2: 인수로 객체 지정하기
- 객체를 생성자 인수로 전달

#### 지역적인 공통 결합과 외부 결합
전역 변수나 싱글턴뿐만 아니라 접근 범위를 구분하는 경우에도 동일하게 적용이 가능.  
모듈이나 패키지의 접근 범위를 지정할 때도 공통 결합이나 외부 결합이 발생하지 않도록 값을 전달

### 6.2.3 제어 결합
- 불필요하게 조건 분기가 세분화된 경우
- 조건 분기의 각 동작이 서로 연관성이 낮은 경우
처럼 무엇을 할 것인지 결장하는 값을 전달하여 호출 대상의 동작을 변경하는 제어 결합

#### 안티패턴1: 불필요하게 조건 분기가 세분화된 경우
- '무엇을 업데이트 하고 있는지'를 파악하기 위해, 모든 분기의 세부 사항을 이해하고, 공통된 로직이 존재하여도, 모든 코드를 읽어야 한다.
#### 개선방법1: 조작 대상에 따라 나누기
- 조건이 아닌 조작 대상별로 코드를 나눔으로써 제어 결합을 좀 더 세밀하게 범위를 한정하고 은닉할 수 있다.

#### 안티패턴2: 조건 분기의 각 동작이 서로 연관성이 낮은 경우
- 함수의 동작 파악을 위해 모든 조건 분기를 읽어야 하며, 동작의 연관성이 낮은 코드는 동작을 하향식으로 파악하는ㄱ 것이 어려움
#### 개선방법2-A: 불필요한 조건 분기 제거하기
- 인수가 정적으로 결정되는 경우, 호출되는 함수를 분할하여 조건 분기를 제거 가능
  - 조건 분기 간의 동작이 서로 연관성이 낮을 때만 제한적으로 적용
#### 개선방법2-B: 조건 분기를 다른 구조로 대체하기
- 인수가 정적으로 결정되지 않는 경우, 함수를 분할하기 보다는 조건 분기를 다른 구조로 대체하는 것이 더 효과적

### 6.2.4 스탬프 결합과 데이터 결합
함수의 인수나 반환값으로 값을 전달할 때, 그것이 제어 결합이 아닐 때
스탬프 결홥가 데이터 결합이 발생.
- 인수나 반환값에 데이터의 구조가 포함된 경우: 스탬프 결합
  - 스탬프 결합이 더 적합
  - 인수나 반환값의 타입에 제약을 두거나 의미를 부여하려는 경우
  - 인수나 반환값 여러 개를 하나로 묶어 단순화하려는 경우
  - 인수나 반환값에 다형성을 적용하려는 경우
- 기본 타입의 값만 전달하는 경우: 데이터 결합

#### 코드 외부에서 정의된 자료 구조
XML, JSON등 데이터 작성 언어로 정의된 모델, 프로토콜에서 규정한 바이너리 형식처럼 장치와의 입출력, 네트워크 통신 등 코드의 외부 요소와 데이터를 주고받을 때, 필요한 자료구조: 외부 정의 데이터

### 6.2.5 메시지 결합
인수나 반환값 등으로 정보를 전달하지 않고, 단순히 함수만 호출할 때 발생하는 결합
- 이벤트 발생을 알리거나
- 리소스를 개방하는 기능

## 6.3 의존 방향
의존의 방향은 한쪽으로만 유지하는 것이 바람직 = 순환이 없어야 한다.

### 6.3.1 호출자 -> 호출 대상
콜백, 클래스 자체의 인스턴스를 전달하거나, 클래스의 인스턴스를 가진 다른 객체를 전달할 때, 순환이 발생.

#### 의존 대상을 최소화하기: 값으로 대체하기
함수의 인수로 this나 내부 클래스, 메소드 참조 등을 전달하고 있따면, 인수가 필요한 이유를 생각.

#### 의존 대상을 최소화하기: 작은 클래스로 추출하기
의존하는 코드나 값을 별도의 작은 클래스로 추출하여 순환을 제거

#### 예외: 콜백이 필요한 경우
- 리스트의 map, forEach등 추상화된 알고리즘을 사용하는 구조
  - map은 호출되는 즉시, 콜백을 실행하고 호출자에게 제어권을 반환할 때 참조를 포기한다: 동기식 콜백
- 비동기적으로 반환되는 값을 처리하는 구조
  - 비동기적으로 반환된 값을 처리하려면 인수로 전달된 콜백을 그대로 가지고 있다가 나중에 실행한다: 비동기식 콜백

### 6.3.2 구체적 -> 추상적
클래스 두 개가 상속 관계에 있고, 자식 클래스와 부모 클래스가 존재 할 때, 부모 클래스에서 자식 클래스를 사용하는 관계를 만든다면, 의존 관계가 순환됨.  
의존관계의 순환을 피하려면 부모 클래스가 자식 클래스를 모르게 해야 함.

### 6.3.3 복잡/가변 -> 단순/불변
- 단순/불변: 넓은 범위에서 오랫동안 사용되거나 좁은 범위에서 사용되다가 금방 참조가 버려짐: 사용되는 범위, 수명 주기, 참조하는 곳의 수가 제각각
- 복잡/가변: 범위, 수명 주기, 참조를 엄격하게 관리해야 함
의존 방향은 복잡/가변 -> 단순/불변 의 단방향으로 이루어 져야함

#### 상황에 따라서는 단순/불변의 코드가 복잡/가변의 코드에 의존해야 하는 경우도 존재
- 중재자 패턴을 채택하는 경우
  - 중재자 패턴: 중재자와 동료 객체로 구성되며, 동료 객체는 서로 직접 통신하지 않고, 중재자를 통해서만 상호작용
  - 중재자는 모든 동료 객체를 알고 있으며, 동료 객체의 상태를 보고 어던 동작을 할 것인지 결정

## 6.4 의존의 중복
### 6.4.1 연결된 의존 관계
단지 참조를 얻기 위한 목적으로만 관련 없는 클래스에 의존하면, 코드가 변경되었을 때  그 영향 범위를 파악하기 어려움
1. 의존성으로 인해 관계없는 코드의 변경까지 염두해야 한다.
2. 의존 관계가 명확하지 않다
- 필요한 참조를 생성자나 함수의 인수로써 명시적으로 전달하는 '직접 의존성 사용'을 통해 해결 가능

#### 디미터의 법칙
- '직접 의존성 사용'을 좀 더 일반적이고, 체계적으로 정의한 개념
- 메소드 내에서 객체의 멤버에 접근할 때, 수신 객체는 다음 중 하나로 제한되어야 한다.
- this 자신
- this의 프로퍼티
- 메소드의 인수
- 메소드 내에서 생성된 객체
- 전역 변수 및 싱글턴

2가지 유의 사항
1. 호출하는 쪽의 책임 범위를 지나치게 넓혀서는 안 된다.
2. 형식적인 회피에 불과한 방법은 선택하지 않아야 한다.

### 6.4.2 의존 대상 집합의 중복
두 개의 클래스는 로컬에 있는 데이터를 사용할 수 있는 경우에는 데이터를 사용하고, 그렇지 않은 경우에는 네트워크 상의 데이터를 취득하여 사용.  
호출하는 쪽 클래스는 공통된 의존 대상을 갖게 됨: 의존 대상의 집합이 중복되는 상태
- '어느 의존 대상을 사용할지 선택하는 코드'가 중복되면 기능을 추가할 때 방해 요소가 될 수 있음

의존 대상 집합의 중복 해결: 중간 레이어를 만들어 각각의 의존 대상들을 숨기는 것이 좋다

## 6.5 의존의 명시성
클래스의 정의만으로는 발견할 수 없는 의존 관계도 존재
- 매개변수, 프로퍼티, 반환값의 타입 등 클래스 정의에서 확인할 수 있는 의존 관계: 명시적 의존 관계
- 클래스 정의만으로 확인할 수 없는 의존 관계: 암묵적 의존 관계

### 6.5.1 안티패턴 1: 과도한 추상화
추상화는 가독성을 향상시키는 효과적인 수단 중하나이지만, 암묵적 의존 관계의 원인이 되기도 한다.
- 추상화는 동작의 흐름을 따라가기 어렵다.
- 과도한 추상화로 인해 코드의 엄격성을 잃을 수 있다.
#### 의존성 주입을 통함 암묵적 의존 관계
- DI 목적
- 모듈간의 상호 의존성 해결
- 구현 교체
- 빌드 고속화
- 도구에 의한 인스턴스 관리

### 6.5.2 안티패턴 2: 암묵적인 값의 범위
함수의 인수가 특정 값만 허용하는 경우, 호출하는 쪽에서 이러한 사양에 대해 알고 있어야 하며, 의존 관계 그래프에 표시되지 않는다.

## 정리
클래스의 의존 관계에서 주의해야 할 점
- 결합도: 내용 결합을 피하고, 공통 결합, 외부 결합, 제어 결합은 완화해야 하는 경우가 있다
- 방향: 불필요한 순환은 피하고, 의존 방향을 결정하는 기준 마련
- 중복: 연결된 의존 관계와 의존 대상 집합의 중복을 피하기 위한 방법
- 명시성: 클래스 정의만으로 의존 관계를 나타낼 수 있는 것이 바람직하며, 과도한 추상화와 암묵적인 값의 범위는 안티패턴


