# item3. 주석
## 주석의 종류와 목적
- 문서화 주석과 비형식 주석  
    - 문서화 주석: 형식적인 설명으로 클래스, 함수, 변수 선언  
    - 비형식 주석: 인라인 주석, 블록 주석  
- 주석의 목적  
    - 코드를 좀 더 빠르게 이해하기 위해: 설명을 간결하게 요약하며, 높은 수준으로 추상화하되, 세분화하여 작성  
    - 실수를 방지하기 위해: 경계 조건이나 특별한 제약 조건  
    - 리팩토링을 쉽게 하기 위해  
    - 그 외의 목적: id or 편집기를 위한 주석, 메타프로그래밍을 위한 주석, 타입이나 제약조건 검증, 지속적 통합 및 테스트...
## 문서화 주석: /**
선언이나 정의룰 정해진 형식으로 작성하는 주석  
클래스, 함수, 변수의 서언이나 정의를 설명하는 형태로 작성  
- 안티패턴
  - 자동으로 생성된 문서를 방치한다.
    - 의미있는 정보를 추가해야 한다. 
  - 선언과 같은 내용을 반복하여 쓴다.
    - 정보를 추가하여 의미 있는 주석으로 만들거나, 주석을 삭제한다.
  - 코드를 자연어로 직역한다.
    - 문서화 주석에서는 코드 구조를 재구성하여 추상화 수준을 높여야 하며, 코드를 쉽게 이해 하도록
  - 개요를 작성하지 않는다.
    - 예외 처리나 경계 조건과 같은 세부적인 사양보다 핵심이 되는 동작의 개요를 먼저 작성
  - 구현의 세부 내용은 언급한다.
    - 코드를 읽는 사람이 구현의 상세를 알고 있지 않는다. 
  - 코드를 사용하는 쪽을 언급한다.
    - 주석은 선언이나 정의에 국한되어야 한다.
## 문서화 주석의 구성
- 코드가 무엇인지, 어떤 일을 하는지를 먼저 간결하게 설명한다
- 코드보다 더 높은 수준의 추상도와 세밀함을 유지한다
- 구현의 상세한 내용이나 코드를 사용하는 쪽을 언급하지 않는다
- 구성
  - 요약을 먼저 작성
  - 세부적인 내용을 보충
## 문서화 주석의 요약
- 요약에서 사용할 문법
  - 클래스 및 변수: 명사구
  - 함수: 3인칭 단수 동사로 시작하고 주어가 생략된 불완전한 문장
- 요약에서 설명하는 내용
  - 기법 1: 중요한 코드 찾기
  - 기법 2: 코드의 공통점 찾기
## 문서화 주석의 상세
- 기본적인 사용법
- 반환값의 보충 설명 
- 제약과 예외 동작
## 비형식 주석
- 규모가 큰 코드 분할하기
- 직관적이지 않은 코드 설명하기
## 정리
- 문서화 주석: 선언이나 정의 부분에 작성하며, 코드를 자세히 읽지 않고도 개요를 이해할 수 있도록 하기 위함. - 해당 코드가 무섯인지, 무엇을 하는지를 설명하는 요약 필
- 비형식 주석: 코드를 읽는 데 도움을 주는 역할을 하며, 큰 코드의 분할이나 직관적이지 않은 코드를 설명하기 위해 작성

# item4. 상태
불필요한 실행 상태의 수를 줄이거나, 상태 전이를 단순하게 하면 코드의 전체 동작을 이해하기 쉽다.
가변을 불변으로 대체하거나, 부수 효과가 없는 함수 사용.
## 4.1: 가변 값이 더 적합한 경우
### 항상 불변이 최적은 아님
## 4.2: 변수 간의 관계, 직교
- 클래스나 모듈을 정의할 때는 변수의 관계가 직교하도록 설계해야 함
### 직교의 정의
- 직교: 두 변수가 있을 때, 한쪽이 취할 수 있는 값의 범위가 다른 한쪽의 값에 영향을 받지 않는, 즉 값이 독립적인 두 변수의 관계
- 비직교: 직교하지 않는 관계
### 함수로 대체하기
- 비직교를 직교로 변환하는 방법은 변수 자체를 제거하는 것 이지만, 종속관계를 따져야 함.
- 종속관계인 경우, 인스턴스 생성이나 상태를 업데이트 하는 인터페이스를 제한하거나, 생성자를 비공개로 설정한 후, 팩토리 함수로 제공
### 합 타입으로 대체하기
- 두 값이 종속 관계가 아니면, 함수로 대체하는 방법을 사용할 수 없음.
- 여러 타입을 묶어서 그 중 하나의 값을 갖는 타입.
- 열거형: 합 타입의 특수한 형태이며, '각 열거자에 해당하는 인스턴스 수는 단 하나이다'라는 제약이 존재.
## 4.3: 상태 전이의 설계
### 불변성
정의, 대입, 객체 생성 이후에 상태가 변하지 않거나 외부에서 관찰할 수 없는 성질
- 불변과 읽기 전용의 차이점
  - 불변과 읽기 전용은 전혀 다른 개념이다.
- 값과 참조의 가변성
  - 변경 가능한 변수를 만들 때는 참조와 참조 대상이 되는 객체를 모두 변경되게 설정하면 안된다.
  - 변수를 가변으로 만들 때, 참조는 변경 가능하게, 객체는 읽기 전용으로/참조는 읽기 전용으로, 객체는 변경 가능하게
- 부분적인 불변성
  - 부분적인 불변성을 유지하여, 값의 생명 주기를 따로 관리
### 멱등성
객체가 취할 수 있는 상태의 수가 두 개 이하이고, 그 상태를 전환하는 함수가 한 개인 경우, 멱등성을 지니도록 하는게 좋음.  
멱등성은 한 번 실행한 결과와 여러 번 실행한 결과가 동일하다는 개념
- 잘못된 상태 전이 제거하기
  - 멱등성을 지닌 함수는 그 함수를 호출하기 전에 현재 상태를 확인하지 않아도 됨. <> 멱등성이 없는 함수를 미리 확인이 필요
- 내부 상태 은닉하기
  - 캐시와 지연평가를 사용하는 함수를 구현 시, 멱등성을 활용하여 내부 상태 숨기기 가능
### 비순환
원래 상태로 돌아가는 전이가 있다면, 그 상태 전이는 순환한다.
가변 객체를 설계 시, 비순환이 되도록 상태 전이를 구성하는 것이 좋음
- 순환이 필요한 경우, 사양 때문에 순환이 불가피한 경우도 존재.
  - 인스턴스 생성과 초기화 비용이 매우 높은 경우에 효과적: 인스턴스 하나를 반복해 사용 가능.
## 정리
- 변수 간의 관계에 직교라는 개념이 잘못된 값의 조합을 제거하는 데 있어 매우 중요
  - 변수를 함수로 대체 하거나, 합 타입으로 대체
- 불변성, 멱등성, 비순환

# item5. 함수
함수 이름, 인수, 반환값의 타입, 주석 등의 정보로 예측하고자 하는 동작
- 반환값이 가질 수 있는 값과 그 값의 의미
- 어떠한 부수 효과를 가지는지
- 오류로 취급되는 조건과 그 때의 동작  

살펴봐야 하는 사항
- 함수 이름의 의미와 함수의 동작이 일치하는 지
- 함수 이름이 충분히 구체적인지
- 무서화 주석의 요역을 쉽게 작성할 수 있는지

## 5.1: 함수의 책임
### 함수 분할의 기본 방침
- 단일 책임 원칙은 클래스 뿐만 아니라 함수에도 적용되어야 한다...
- 요약을 해주는 문서화 주석을 작성해보되, 요약하기가 어렵다면, 여러 책임을 지고 있을 가능성이 높다
### 명령과 쿼리의 분리(CQS)
상태를 변경하기 위한 함수(명령)와 상태를 알기 위한 함수(쿼리) 분리
- 명령: 수신 객체나 인수, 외부의 상태를 변경하는 함수. 반환값을 가지지 않는다.
- 쿼리: 반환값으로 정보를 취득하는 함수. 수신 객체나 인수, 외부의 상태는 변경하지 않는다.
### 함수의 흐름
동작의 흐름이 명확한 함수는 짧은 시간에 대략적으로 훑어봐도 내용을 파악 가능
- 세부 동작을 읽지 않고도 이해할 수 있다
- 함수의 핵심이 된느 부분을 쉽게 파악할 수 있다
- 모든 조건 분기를 확인하지 않아도 이해할 수 있다

### 정의 기반 프로그래밍
- 중첩, 메소드 체인, 리터럴 등을 사용하는 대신 이름이 있는 변수, 함수, 클래스의 정의를 주요 사용
- 높은 수준의 추상화
- 빠르게 읽어 내려가도 쉽게 파악할 수 있는 코드
- 되짚어 읽지 않아도 되는 코드
- 개선해야 할 패턴
  - 중첩: 구조가 재귀적으로 반복되는 상태
  - 메소드 체인: 메소드의 반환값을 새로운 수신 객체로 삼아, 또 다른 메소드를 호출하는 것
  - 리터럴: 소스 코드에서 직접 표현된 값
### 조기반환
- 함수 구현의 초반부에 실패 경로를 처리하는 부분을 모아두고, return으로 함수 종료
- 조기 반환 시 주의할 점
  - 이해하기 어려운 반환은 피할 것
  - 불필요한 실패 경로를 만들지 말 것
### 조작 대상에 따른 분할
- 조건에 따라 분할하는 방법과 조작할 대상에 따라 분할하는 방법 2개가 있는데, 조작할 대상에 따른 분할을 먼저 실시
- 안티패턴
  - 조건에 따라 분할한 후 조작 대상에 따라 분할
- 개선 예시
  - 조작 대상에 따라 분할한 후 조건에 따라 분할
- 추가 리팩토링
- 모든 분기가 다루어지고 있음을 보장하기 어려운 경우 
- 조기 반환과 조작 대상에 따른 분할의 우선순위
  1. 조작 대상에 따른 분할을 먼저 적용: 조작 대상별로 보조 함수를 만든 뒤, 각 보조 함수 내에서 조기 반환을 수행한다.
  2. 조기 반환읆 ㅓㄴ저 적용: 조기 반환으로 실패 경로를 제거한 뒤 성공 경로를 조작 대상별로 분할한다.
  3. 일반적으로 성공 경로와 실패 경로의 조작 대상이 동일하다면, '조작 대상에 따른 분할'을 먼저 적용/ 크게 다르다면, '조기 반환'을 먼저 적용
## 정리
- 함수의 동작을 예측 가능하게 만드,ㄹ기 위해, 책임과 흐름을 명확히 하는 것이 중요.
- 책임과 흐름이 명확한지의 여부
  - 함수의 네이밍을 쉽게 할 수 있는지
  - 문서화 주석을 쉽게 작성할 수 있는지
- 책임을 명확히
  - 단일 책임의 원칙
  - 명령과 쿼리 분리
- 흐름을 명확히
  - 정의 기반 프로그래밍
  - 조기 반환
  - 조작 대상에 따른 분할
