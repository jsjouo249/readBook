# item8. 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조
결합도란 모듈(클래스) 사이의 의존도를 나타내는 지표

## 결합도와 책무
- 다양한 버그
- 로직의 위치에 일관성이 없음
- 단일 책임 원칙 - 클래스가 담당하는 책임은 하나로 제한해야 한다.
- 단일 책임 원칙 위반으로 발생하는 악마
- 책임이 하나가 되게 클래스 설계하기
- DRY 원칙 (Don't Repeat Yourself)의 잘못된 적용
  - 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다. === 같은 로직, 비슷한 로직이라도 개념이 다르면 중복 허용
## 다양한 강한 결합 사례와 대처 방법
- 상속과 관련된 강한 결합
  - 슈퍼 클래스 의존 - 서브 클래스는 슈퍼 클래스에 크게 의존
  - 상속보다 컴포지션 - 사용하고 싶은 클래스를 private 인스턴스 변수로 갖고 사용
  - 상속을 사용하는 나쁜 일반화 
    - 상속받는 쪽에서 차이가 있는 로직만 구현하는 템플릿 메소드가 있음
- 인스턴스 변수별로 클래스 분할이 가능한 로직
- 특별한 이유 없이 public 사용하지 않기
  - 패키지는 밀접한 클래스끼리 응집하게 설계, 패키지 바깥의 클래스와는 느슨하게 결합
- private 메소드가 너무 많다는 것은 책임이 너무 많다는 것
- 높은 응집도를 오해해서 생기는 강한 결합
- 스마트 UI - 화면 표시를 담당하는 클래스 중에서 화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스
- 거대 데이터 클래스
- 트랜잭션 스크립트 패턴 - 메소드 내부에서 일련의 처리가 하나하나 길게 작성되어 있는 구조
- 갓 클래스 - 하나의 클래스 내부에서 수천~수만 줄의 로직을 담으며, 책임을 담당하는 로직이 난잡하게 섞인 클래스
- 강한 결합 클래스 대처 방법

컴포지션을 사용하여 클래스 간의 결합도를 낮추기 - 좋은 방법

# item9. 설계의 건전성을 해치는 여러 악마
## 데드 코드(도달 불가능한 코드) - 절대 실행되지 않는 조건 내부에 있는 코드
## YAGNI 원칙 - You Aren't Gonna Need It
## 매직 넘버
## 문자열 자료형에 대한 집착
## 전역 변수
- 영향 범위가 최소화되도록 설계하기
## Null 문제
- null을 리턴/전달 하지 않기
- null 안전 자료형
## 예외를 catch하고서 무시하는 코드
- 원인 분석을 어렵게 만듦
- 문제가 발생했다면 소리치기
## 설계 질서를 파괴하는 메타 프로그래밍
- 리플렉션으로 인한 클래스 구조와 값 변경 문제 - 임의의 클래스에 접근할 수 있는 기능
- 자료형의 장점을 살리지 못하는 하드 코딩
- 단점을 이해하고 용도를 한정해서 사용하기
## 기술 중심 패키징
## 샘플 코드 복사해서 붙여넣기
## 은 탄환 - 한 가지 절대적인 방법으로 모든 것을 해결할 수 없다.

설계에 Best라는 것은 없이, 항상 Better를 목표로 한다.
