# item7. URL 단축기 설계

## 1. 문제 이해 및 설계 범위 확정
예시)
- URL 단축: 주어진 긴 URL을 훨씬 짧게 줄인다
- URL 리디렉션: 축약된 URL로 HTTP 요청이 오면, 원래 URL로 안내
- 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구됨

개략적 추정
- 쓰기 연산: 매일 1억개의 단축 URL 생성
- 초당 쓰기 연산: 1억/24/3600 = 1160
- 읽기 연산: 10:1이라고 가정하여, 초당 11600회
- 10년간 운영하면, 1억 * 365 * 10 = 3650억개의 레코드 보관
- 축약 전 URL의 길이는 100
- 저장용량은 3650 * 100byte = 36.5TB

## 2. 개략적 설계안 제시 및 동의 구하기
API
- post
- get
  - 301 Permanently moved: 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 명시된 URL로 이전됨 => 브라우저는 이 응답을 캐시 함
    - 즉, 추후 같은 단축 URL에 요청을 보낼 필요가 있을 때, 브라우저는 캐시된 원래 URL로 요청을 보내게 된다.
  - 302 Found: 주어진 URL로의 요청이 '일시적'으로 Location 헤더가 지정하는 URL에 의해 처리되어여 한다.
    - 즉, 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 된다.

각각의 장단점
- 301: 서버 부하르 줄여야 한다.
- 302: 트래픽 분석이 중요하다.

해시 테이블 사용이 대표적

### URL 단축
- 입력으로 주어지는 긴 URL이 다른 값이면, 해시 값도 달라야 한다.
- 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

## 3. 상세 설계
### 데이터 모델
해시 테이블을 사용하기엔 좋지만, 메모리는 유한하고 비싸다.
<단축 URL, 원래 URL>의 순서쌍을 rdb에 저장

### 해시 함수
해시 함수는 원래 URL을 단축 URL로 변환하는데 쓰임.
hashValue는 [0-9,a-z,A-Z]로 구성된 62진수로 변환
3650억개의 URL이니,
62^7 = 3.5조 가 되는 hashValue = 7이 되어야 해서, hashValue의 길이는 7로 한다.

해시 함수 구현에 쓰일 기술
- 해시 후 충돌 해소
- base-62 변환

### 해시 후 충돌 해소
- CRC32, MD5, SHA-1 등의 해시 함수를 사용  
하지만 다 길이가 길어서, 7글자는 안됨.

처음의 7글자만 사용한다 - 해시 결과가 서로 충돌한다.
- 충돌 해소 로직
시작 -> longURL -> 해시 함수 -> shortURL -> db에 있나(충돌) -> 예 -> longURL뒤에 사전에 정한 문자열 추가 (반복)
                                                        -> 아니오 -> db에 저장 -> 종료
- 계속 db를 질의해야되서, 오버헤드가 큼

#### db대신 블룸 필터를 사용하여 성능을 높임

### base-62 변환
62진법을 사용한다.
hashValue에 문자가 62개여서, 62진법 사용

| 해시 후 충돌 해소 전략                                          | base-62변환                                            |
|--------------------------------------------------------|------------------------------------------------------|
| 단축 URL의 길이가 고정됨                                        | 단축 URL의 길이가 가변적. ID 값이 커지면 같이 길어짐                    |
| 유일성이 보장되는 ID 생성기가 필요치 않음                               | 유일성 보장 ID 생성기가 필요                                    |
| 충돌이 가능해서 해소 전략이 필요                                     | ID의 유일성이 보장된 후에야 적용 가능한 전략이라, 충돌은 아예 불가능             |
| ID로부터 단축 URL을 계산하는 방식이 <br/>아니라서 다음에 쓸 수 있는 URL 알기 불가능 | ID가 1씩 증가하는 값이라면, 다음에 쓸 단축 URL을 알기 때문에, 보안상 문제 소지 있음 |


### URL 단축기 상세 설계
1. 입력으로 긴 URL 받음
2. db에 해당 URL 있는지 확인
3. 있다면, 단축 URL 반환
4. 없다면, 유일한 ID 생성
5. 62진법을 적용, 단축 URL 생성
6. id, 단축 URL, 원래 URL을 db에 저장 후, 단축 URL 반환

- ID 생성기
7장에서 언급한 분산 ID 생성기

### URL 리디렉션 상세 설계
1. 사용자가 단축 URL 클릭
2. lb가 해당 클릭으로 발생한 요청을 웹서버에 전달
3. 단축 URL이 이미 캐시에 있으면, 원래 URL 반환
4. 캐시에 없다면, db에서 꺼냄 
   5. db에 없다면, 잘못된 단축 URL 입력
6. db에서 꺼낸 URL을 캐시에 저장 후, 반환

## 4. 마무리
- 처리율 제한 장치: 엄청난 양의 URL 단축 요청이 오면, 무력화 될 수 있음. 처리율 제한 장치로 필터링
- 웹 서버의 규모 확장: 무상태 계층이므로, 웹 서버 자유로이 증설 및 삭제 가능
- 데이터베이스의 규모 확장: db의 다중화 및 샤딩 가능
- 데이터 분석 솔루션
- 가용성, 데이터 일관성, 안정성